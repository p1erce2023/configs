{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "leetcode template": {
        "prefix": "leetcode",
        "description": "leetcode cpp template.",
        "body": [
            "#include <algorithm>",
            "#include <array>",
            "#include <cstdint>",
            "#include <iostream>",
            "#include <iterator>",
            "#include <map>",
            "#include <numeric>",
            "#include <queue>",
            "#include <set>",
            "#include <stack>",
            "#include <string>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include <utility>",
            "#include <vector>",
            "using namespace std;",
            "#define OUT(...) cout << __VA_ARGS__ << '\\n'",
            "",
            "using UMPII = unordered_map<int,int>;",
            "using VVI = vector<vector<int>>;",
            "using LL = long long;",
            "using VI = vector<int>;",
            "$0",
            "",
            "int main() {",
            "    auto sol = Solution();",
            "    // parameters init",
            "    OUT(sol);",
            "}",
            ""
        ]
    },
    "sort": {
        "prefix": "sort",
        "body": "sort($0.begin(), $0.end());"
    },
    "accumulate": {
        "prefix": "accumulate",
        "body": "accumulate($0.begin(), $0.end(), 0ll);"
    },
    "reverse": {
        "prefix": "reverse",
        "body": "reverse($0.begin(), $0.end());"
    },
    "lower_bound": {
        "prefix": "lower_bound",
        "body": "lower_bound($0.begin(), $0.end(), );"
    },
    "upper_bound": {
        "prefix": "upper_bound",
        "body": "upper_bound($0.begin(), $0.end(), );"
    },
    "max_element": {
        "prefix": "max_element",
        "body": "max_element($0.begin(), $0.end());"
    },
    "min_element": {
        "prefix": "min_element",
        "body": "min_element($0.begin(), $0.end());"
    },
    "priority_queue min": {
        "prefix": "pq min",
        "body": [
            "using pq_elem = $0;",
            "priority_queue<pq_elem, vector<pq_elem>, greater<>> pq; // min heap"
        ]
    },
    "ListNode util": {
        "prefix": "ListNode util",
        "body": [
            "struct ListNode {",
            "    int val;",
            "    ListNode *next;",
            "    ListNode() : val(0), next(nullptr) {}",
            "    ListNode(int x) : val(x), next(nullptr) {}",
            "    ListNode(int x, ListNode *next) : val(x), next(next) {}",
            "};",
            "ListNode* createList(vector<int>& v) {",
            "    int n=v.size();",
            "    ListNode *last = nullptr, *head;",
            "    for (int i=0; i<n; ++i) {",
            "        if (last == nullptr) {",
            "            head = new ListNode(v[i]);",
            "            last = head;",
            "        } else {",
            "            last->next = new ListNode(v[i]);",
            "            last = last->next;",
            "        }",
            "    }",
            "    return head;",
            "}",
            "void coutList(ListNode* head) {",
            "    while (head) {",
            "        std::cout << head->val << ' ';",
            "        head = head->next;",
            "    }",
            "    std::cout << '\\n';",
            "}",
        ]
    },
    "linked list undirected": {
        "prefix": "linkedlist undirected",
        "description": "transform undirected graph edges [(ai, bi)] to linked_list [[bi],[ai]]",
        "body": [
            "vector<vector<int>> e(n);",
            "for (auto& ee : edges) {",
            "    e[ee[0]].push_back(ee[1]);",
            "    e[ee[1]].push_back(ee[0]);",
            "}",
            "$0"
        ]
    },
    "linked list directed" : {
        "prefix": "linkedlist directed",
        "body": [
            "vector<pair<vector<int>,vector<int>>> e(n);  // <in,out>",
            "for (auto& ee : edges) {",
            "    e[ee[0]].second.push_back(ee[1]);",
            "    e[ee[1]].first.push_back(ee[0]);",
            "}",
        ]
    },
    "dfs": {
        "prefix": "depth first search",
        "body": [
            "vector<vector<int>> e(n);",
            "for (auto& ee : edges) {",
            "    e[ee[0]].push_back(ee[1]);",
            "    e[ee[1]].push_back(ee[0]);",
            "}",
            "int seen[n];",
            "memset(seen, 0, sizeof(seen));",
            "vector<int> q={0};",
            "seen[0] = 1;",
            "int x;",
            "while (!q.empty()) {",
            "    x = q.back();",
            "    q.pop_back();",
            "    for (int y : e[x]) {",
            "        if (seen[y]) continue;",
            "        seen[y] = 1;",
            "        $0",
            "        q.push_back(y);",
            "    }",
            "}",
        ]
    },
    "bfs": {
        "prefix": "breadth first search",
        "body": [
            "vector<vector<int>> e(n);",
            "for (auto& ee : edges) {",
            "    e[ee[0]].push_back(ee[1]);",
            "    e[ee[1]].push_back(ee[0]);",
            "}",
            "vector<int> d(n,-1);",
            "d[0] = 0;",
            "int dis = 1;",
            "vector<int> v={0}, nv;",
            "while (!v.empty()) {",
            "    for (int x : v) {",
            "        for (int y : e[x]) {",
            "            if (d[y] != -1) continue;",
            "            d[y] = dis;",
            "            nv.push_back(y);",
            "        }",
            "    }",
            "    v = std::move(nv);",
            "    ++dis;",
            "}",
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "vector<int> manacher_odd(string s) {",
            "    // https://cp-algorithms.com/string/manacher.html",
            "    // init p[i] = 1",
            "    int n = s.size();",
            "    s = \"$\" + s + \"^\";",
            "    vector<int> p(n + 2);",
            "    int l = 1, r = 1;",
            "    for(int i = 1; i <= n; i++) {",
            "        p[i] = max(1, min(r - i, p[l + (r - i)]));",
            "        while(s[i - p[i]] == s[i + p[i]]) {",
            "            p[i]++;",
            "        }",
            "        if(i + p[i] > r) {",
            "            l = i - p[i], r = i + p[i];",
            "        }",
            "    }",
            "    return vector<int>(begin(p) + 1, end(p) - 1);",
            "}",
        ]
    },
    "disjoint set union": {
        "prefix": "dsu",
        "body": [
            "// Standard Disjoint-set data structure implementation.",
            "class DSU {",
            "    vector<int> Parent, Rank;",
            "public:",
            "    DSU(int n) {",
            "        Parent.resize(n);",
            "        Rank.resize(n, 0);",
            "        for (int i=0; i<n; i++) Parent[i] = i;",
            "    }",
            "    int Find(int x) {",
            "        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);",
            "    }",
            "    bool Union(int x, int y) {",
            "        x = Find(x), y = Find(y);",
            "        if (x == y) return false;",
            "        Rank[x] < Rank[y] ? Parent[x] = y : Parent[y] = x;",
            "        Rank[x] += Rank[x] == Rank[y];",
            "        return true;",
            "    }",
            "};",
        ]
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "struct Trie {",
            "    Trie* ch[26] = {};",
            "    bool e = false;",
            "    void insert(string &w) {",
            "        auto n = this;",
            "        for (auto c : w) {",
            "            if (n->ch[c - 'a'] == nullptr)",
            "                n->ch[c - 'a'] = new Trie();",
            "            n = n->ch[c - 'a'];",
            "        }",
            "        n->e = true;",
            "    }",
            "    bool search(string &w) {",
            "        auto n = this;",
            "        for (auto c : w) {",
            "            if (n->ch[c - 'a'] == nullptr)",
            "                return false;",
            "            n = n->ch[c - 'a'];",
            "        }",
            "        return n->e;",
            "    }",
            "}; ",
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "description": "use dijkstra to find minimum distance from source->target",
        "body": [
            "int s, t;",
            "priority_queue<pair<double,int>, vector<pair<double,int>>, std::greater<>> pq;",
            "double relaxed, INT_MAX=1e9;",
            "vector<double> dis(n, INT_MAX);",
            "dis[s] = 0;",
            "pq.push({0,0});",
            "while (!pq.empty()) {",
            "    auto [val, x] = pq.top();",
            "    pq.pop();",
            "    if (x == t) break;",
            "    if (val != dis[x]) continue;",
            "    for (auto [y, w] : e[x]) {",
            "        relaxed = dis[x] + w;",
            "        if (relaxed < dis[y]) {",
            "            pq.push({relaxed, y});",
            "            dis[y] = relaxed;",
            "        }",
            "    }",
            "}",
            "return dis[t] == INT_MAX? -1 : dis[t];",
        ]
    },
    "floyd warshall": {
        "prefix": "floyd warshall",
        "description": "all pair shortest path",
        "body": [
            "vector<vector<int>> d(n, vector<int>(n, 1e5+1));",
            "for (int i=0; i<n; ++i)",
            "    for (int j=0; j<n; ++j)",
            "        d[i][j] = e[i][j];",
            "// O(n^3)",
            "for (int k=0; k<n; ++k)",
            "    for (int i=0; i<n; ++i)",
            "        for (int j=0; j<n; ++j)",
            "            if (d[i][j] > d[i][k] + d[k][j])",
            "                d[i][j] = d[i][k] + d[k][j];",
        ]
    },
    "topological sort": {
        "prefix": "topological sort",
        "body": [
            "int n, seen=0;",
            "vector<int> dg(n), q, nq;",
            "vector<vector<int>> e(n);",
            "for (auto& ee : edges) {",
            "    e[ee[1]].push_back(ee[0]);",
            "    dg[ee[0]]++;",
            "}",
            "for (int i=0; i<n; ++i) {",
            "    if (dg[i] == 0) {",
            "        q.push_back(i);",
            "    }",
            "}",
            "seen = q.size();",
            "while (!q.empty()) {",
            "    for (int x : q) {",
            "        for (int y : e[x]) {",
            "            dg[y]--;",
            "            if (dg[y] == 0)",
            "                nq.push_back(y);",
            "        }",
            "    }",
            "    q = std::move(nq);",
            "    seen += q.size();",
            "}",
        ]
    },
    "binary search": {
        "prefix": "bisect",
        "description": "binary search",
        "body": [
            "int left, right, mid;",
            "while (left < right) {",
            "    mid = left + (right - left) / 2;",
            "    if (condition)",
            "        right = mid;",
            "    else",
            "        left = mid + 1;",
            "}",
            "return left;",
        ]
    },
    "cout vector": {
        "prefix": "cout vector",
        "description": "cout vector",
        "body": [
            "for (auto vi : $0) { std::cout << vi << ' '; }",
            "std::cout << std::endl;",
        ]
    },
    "cout vector<vector<>>": {
        "prefix": "cout vector<vector<>>",
        "body": [
            "auto vvv = $0;",
            "std::cout << '[';",
            "for (int ii=0; ii<vvv.size()-1; ii++) {",
            "    std::cout << '[';",
            "    for (int jj=0; jj<vvv[ii].size()-1; jj++)",
            "        std::cout << vvv[ii][jj] << ',';",
            "    std::cout << vvv[ii].back() << \"],\";",
            "}",
            "std::cout << '[';",
            "for (int jj=0; jj<vvv.back().size()-1; jj++)",
            "    std::cout << vvv.back()[jj] << ',';",
            "std::cout << vvv.back().back() << ']';",
            "std::cout << ']' << std::endl;",
        ]
    },
    "cout unordered_map": {
        "prefix": "cout umap",
        "description": "cout unordered_map",
        "body": [
            "for (auto [kk, vv] : $0) { std::cout << kk << ':' << vv << \", \"; }",
            "std::cout << std::endl;",
        ]
    },
    "(recursive) fast exponentiation": {
        "prefix": "fast exponentiation recursive",
        "body": [
            "int expMod(int a, int p, int MOD) {",
            "    if (p == 0) return 1;",
            "    if (p & 1) return (1ll * a * expMod(a, p - 1, MOD)) % MOD;",
            "    int half = expMod(a, p / 2, MOD);",
            "    return (1ll * half * half) % MOD;",
            "}",
        ]
    },
    "(iterative) fast exponentiation": {
        "prefix": "fast exponentiation iterative",
        "body": [
            "int expMod(int a, int p, int MOD) {",
            "    int ans = 1;",
            "    while (p) {",
            "        if (p & 1) ans = (1ll * ans * a) % MOD;",
            "        a = (1ll * a * a) % MOD;",
            "        p >>= 1;",
            "    }",
            "    return ans;",
            "}",
        ]
    },
    "DivideThenMod": {
        "prefix": "divide then mod",
        "body": [
            "int expMod(int a, int p, int MOD) {",
            "    int ans = 1;",
            "    while (p) {",
            "        if (p & 1) ans = (1ll * ans * a) % MOD;",
            "        a = (1ll * a * a) % MOD;",
            "        p >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "int divideThenMod(int a, int b, int MOD) {",
            "    int ans = expMod(b, MOD-2, MOD);",
            "    ans = (1ll * a * ans) % MOD;",
            "    return ans;",
            "}",
        ]
    },
    "prime sieve": {
        "prefix": "prime sieve",
        "body": [
            "vector<bool> prime(n+1, 1);",
            "prime[1]=0;",
            "for (long long i=2; i<=n; ++i) {",
            "    if (!prime[i])",
            "        continue;",
            "    for (long long j=i*i; j<=n; j+=i)",
            "        prime[j]=0;",
            "}",
        ]
    },
    "BigNumberArithmetic": {
        "prefix": "arithmetic",
        "body": [
            "int mult(int a, int b) { return (1ll*a*b) % MOD; }",
            "int add(int a, int b) { return (0ll+a+b) % MOD; }",
        ]
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "int dp[1001][1001] = {};",
            "int MOD = 1e9+7;",
            "int combination(int n, int m) {",
            "    return (n==0 || m==0 || n==m)? 1 :",
            "        dp[n][m] ? dp[n][m] : ",
            "            dp[n][m] = (combination(n-1, m) + combination(n-1, m-1)) % MOD;",
            "}",
        ]
    },
    "ncr": {
        "prefix": "combination fast, ncr",
        "body": [
            "const int MOD=1e9+7, MX=$0;",
            "int mult(int a, int b) { return (1ll*a*b) % MOD; }",
            "int fact[MX], inv[MX], invfact[MX];",
            "void init_INV() {",
            "    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;",
            "    for (int i = 2; i < MX; ++i) {",
            "        fact[i] = mult(fact[i - 1], i);",
            "        inv[i] = mult(inv[MOD % i], MOD - MOD / i);",
            "        invfact[i] = mult(invfact[i - 1], inv[i]);",
            "    }",
            "}",
            "int ncr(int n, int r) {",
            "    if (r > n) return 0;",
            "    return mult(mult(fact[n], invfact[n-r]), invfact[r]);",
            "}",
        ]
    },
    "compress mapping": {
        "prefix": "compress mapping",
        "body": [
            "int n=A.size();",
            "vector<int> B(A), AA(n);",
            "sort(B.begin(), B.end());",
            "B.erase(std::unique(B.begin(), B.end()), B.end());",
            "unordered_map<int, int> d;",
            "for (int i=0; i<B.size(); i++) d[B[i]] = i;",
            "for (int i=0; i<n; i++) AA[i] = d[A[i]];",
        ]
    },
    "fenwick tree": {
        "prefix": "fenwick tree",
        "description": "fenwick tree / binary indexed tree (BIT)",
        "body": [
            "class NumArray {",
            "    vector<int> v, ss;  // original, BIT",
            "    int n;",
            "public:",
            "    NumArray(vector<int>& nums) {",
            "        n = nums.size();",
            "        v.resize(n,0);",
            "        ss.resize(n+1,0);",
            "        for (int i=0; i<n; i++) update(i,nums[i]);",
            "    }",
            "",
            "    void update(int index, int val) {",
            "        int d = val-v[index];",
            "        v[index] = val;",
            "        for (int i=index+1; i<=n; i+=(i&-i)) ss[i] += d;",
            "    }",
            "",
            "    int sumRange(int left, int right) {",
            "        int s=0;",
            "        for (int i=right+1; i; i-=(i&-i)) s += ss[i];",
            "        for (int i=left; i; i-=(i&-i)) s -= ss[i];",
            "        return s;",
            "    }",
            "};",
        ]
    },
    "zkw segment tree": {
        "prefix": "segment tree zkw",
        "body": [

        ]
    },
    "segment max tree": {
        "prefix": "segment max tree",
        "body": [
            "class MaxSegmentTree {",
            "public:",
            "    int n;",
            "    vector<int> tree;",
            "    MaxSegmentTree(int n_) : n(n_) {",
            "        int sz = (int)(ceil(log2(n)));",
            "        sz = (2 * pow(2, sz)) - 1;",
            "        tree.resize(sz);",
            "    }",
            "",
            "    int max_value() { return tree[0]; }",
            "",
            "    int query(int l, int r) { return query_util(0, l, r, 0, n - 1); }",
            "",
            "    int query_util(int i, int qL, int qR, int l, int r) {",
            "        if (l >= qL && r <= qR)",
            "            return tree[i];",
            "        if (l > qR || r < qL)",
            "            return INT_MIN;",
            "    ",
            "        int m = (l + r) / 2;",
            "        return max(query_util(2 * i + 1, qL, qR, l, m),",
            "                    query_util(2 * i + 2, qL, qR, m + 1, r));",
            "    }",
            "",
            "    void update(int i, int val) { update_util(0, 0, n - 1, i, val); }",
            "",
            "    void update_util(int i, int l, int r, int pos, int val) {",
            "        if (pos < l || pos > r)",
            "            return;",
            "        if (l == r) {",
            "            tree[i] = max(val, tree[i]);",
            "            return;",
            "        }",
            "",
            "        int m = (l + r) / 2;",
            "        update_util(2 * i + 1, l, m, pos, val);",
            "        update_util(2 * i + 2, m + 1, r, pos, val);",
            "        tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);",
            "    }",
            "};",
        ]
    },
    "segment tree": {
        "prefix": "segment tree",
        "description": "segment tree template with lazy propagation",
        "body": [
            "void build_tree(int low, int high, int pos, vector<int>& arr, vector<int>& seg) {",
            "    if (low == high) {",
            "        seg[pos] = arr[low];",
            "        return;",
            "    }",
            "    int mid = (low + high) / 2;",
            "    build_tree(low, mid, 2*pos+1, arr, seg);",
            "    build_tree(mid+1, high, 2*pos+2, arr, seg);",
            "    seg[pos] = ****(seg[2*pos+1], seg[2*pos+2]);  // min, max, sum, or other suitable operation",
            "}",
            "",
            "int range_query_lazy(int low, int high, int pos, int qlow, int qhigh, vector<int>& seg, vector<int>& lazy) {",
            "    if (lazy[pos] != 0) {",
            "        seg[pos] += lazy[pos];",
            "        if (low != high) {  // not a leaf node",
            "            lazy[2*pos+1] += lazy[pos];",
            "            lazy[2*pos+2] += lazy[pos];",
            "        }",
            "        lazy[pos] = 0;",
            "    }",
            "    if (qlow <= low && high <= qhigh) return seg[pos];",
            "    if (high < qlow || low > qhigh) return ****_opposite;  // customed impossible value",
            "    int mid = (low + high) / 2;",
            "    return ****(",
            "        range_query_lazy(low, mid, 2*pos+1, qlow, qhigh, seg, lazy),",
            "        range_query_lazy(mid+1, high, 2*pos+2, qlow, qhigh, seg, lazy)",
            "    );",
            "}",
            "",
            "void update_range_lazy(int low, int high, int pos, int qlow, int qhigh, int delta, vector<int>& seg, vector<int>& lazy) {",
            "    if (low > high) return;",
            "",
            "    if (lazy[pos] != 0) {",
            "        seg[pos] += lazy[pos];",
            "        if (low != high) {  // not a leaf node",
            "            lazy[2*pos+1] += lazy[pos];",
            "            lazy[2*pos+2] += lazy[pos];",
            "        }",
            "        lazy[pos] = 0;",
            "    }",
            "",
            "    if (qlow <= low&& high <= qhigh) {  // total overlap",
            "        seg[pos] += delta;",
            "        if (low != high) {",
            "            lazy[2*pos+1] += delta;",
            "            lazy[2*pos+2] += delta;",
            "        }",
            "        return;",
            "    }",
            "",
            "    if (low > qhigh || high < qlow) return;  // no overlap",
            "",
            "    int mid = (low + high) / 2;",
            "    update_range_lazy(low, mid, 2*pos+1, qlow, qhigh, delta, seg, lazy);",
            "    update_range_lazy(mid+1, high, 2*pos+2, qlow, qhigh, delta, seg, lazy);",
            "    seg[pos] = ****(seg[2*pos+1], seg[2*pos+2]);",
            "}",
            "$0"
        ]
    }
}









